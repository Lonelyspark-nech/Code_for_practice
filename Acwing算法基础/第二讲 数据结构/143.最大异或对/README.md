143.最大异或对
===
https://www.acwing.com/problem/content/description/145/

给定N个数，大小不超过2^31，求选出任意两个数进行异或运算结果的最大值。可以使用Trie树完成。

将数字转化为二进制，最多有31位。然后当作字符串处理，加入Trie树即可。从结果上讲，由于这样做把数字按二进制位拆分开，会使后面的条件判断更加方便。

可以使用bitset拆分。bitset类可以将数字按二进制位拆开，支持按位遍历。在本题中，位数从高到低是30到0。但是实际操作中发现，效率远不如直接按位取值。即使由于需要从高到低取值，取高位时需要移动的位数较多，并且后面需要重复移动。在本题中，使用bitset需要的时间大概是按位取值的4到5倍。

由于是二进制表示，每位只有0和1，也就是说每个结点只有最多两个子节点。对于两个结点来讲，如果前者的0子节点和后者的1子结点有值，或者相反，这意味着在这一位上异或结果是1。这两个可以同时成立，需要求解两次。否则，这两个结点一定会同时在0或者在1子节点上有值。这两个有且仅有一个成立。遍历深度是32，从31到0。每次遍历需要将当前的异或结果值右移一位，若该位的异或值为1，则结果再+1。当遍历到-1时，将求得的异或值和维护的最大值比较，如果有必要就更新最大值。然后回溯，遍历其他分支。

这道题可以在遍历的过程中进行剪枝。方法是，假设从当前结点开始，本位和更低的位异或值全部取1，求出一个结果。如果该结果小于维护的最大结果，则直接剪枝，不需要对该分支进行遍历。但是实际操作中发现，是否剪枝对这道题的运行速度影响不大，还会带来错误的风险。

