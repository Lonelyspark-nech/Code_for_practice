826.单链表
==
https://www.acwing.com/problem/content/828/

本题要求实现一个单链表。

在限时的算法竞赛中，更常用数组来模拟链表（静态链表），因为new操作需要的时间极长。具体做法是，定义两个足够大的数组，e[N]和ne[N]。其中，e[N]表示该结点中存储的数据，ne[N]表示该结点的next指针指向哪个结点。此外，使用一个int idx，指向下一个可以插入数据的位置。另外有一个int head指向链表的第一个结点。

具体的模拟方式是，每次插入结点都使用两个数组中的idx对应下标的各一个元素存储数据和指针，然后idx自加。初始时，idx指向0，head指向-1（用-1表示链表结束）。也就是说，第k个插入的元素会存放在两个数组的k-1下标处（数组的下标是从0开始的）。

本题要求实现三个基本操作：

第一，向链表头插入一个数。只需在idx的位置写入数据，然后令ne[idx]指向原来的链表头，head指向idx即可。那之后，idx++。

第二，删除第K个插入的元素后面的一个元素，若K=0，则删除链表头。只需让ne[k]指向下下个元素即可。当删除链表头时，令head指向ne[head]。这样做会使被删除的元素不出现在链表中，但是实际上空间没有被释放，也几乎无法再次利用。在算法题中，这属于很小的问题。

第三，在第K个插入的数后面插入一个数。类似于第一条，把head修改为第K个插入的数即可。

需要注意两点：

第一，链表插入计数从1开始，但是数组计数从0开始。所以在代码中，第K个插入的元素实际上是e[k-1]和ne[k-1]。实现时需要注意。

第二，关于scanf读取字符类型。scanf读取数据时，会把回车留在缓冲区中。如果下一次用scanf读取数值或字符串时不会有问题，这个回车会被跳过（忽略空格、回车等的空白字符）。但是如果下一次用scanf读取字符类型，会读到这个回车，造成混乱。有几个方法解决：

1.使用fflush(stdin)清空输入缓存。仅在windows下有效。

2.在需要的地方使用getchar()读取（并消耗掉）回车。

3.读取时使用%*c（读取一个字符，但不赋值给任何变量）读取回车。比如scanf("%d%*c",&a);，这样会给a赋值，同时缓冲区不会留下回车。