845.八数码
==
https://www.acwing.com/problem/content/description/847/

本题考察bfs。这种移动方式实际上就是古早按键机中的拼图游戏，求拼完的最少步数。

本题实际不难，但是卡了我很久。主要卡在输入难以过滤空格上。事实上，需要记得，string的+运算是拼接，可以将字符一个一个拼接起来。单个字符或者单词的输入，使用cin也可以，使用scanf读入字符串也可以。把空格过滤掉，状态就是一个string了。

每个拼图状态虽然表面上是3*3的矩阵，但是可以用string处理。状态转移可以写成和上一道题一样的向量形式（对于x的下标n，将其还原成矩阵中的坐标时，横坐标是n/3，纵坐标是n%3），也可以直接写成4个if。单纯是代码量和可读性上的差别，性能上没什么区别。

本题需要储存目前遍历到的状态是否之前曾经遍历到过。可以使用STL中的unordered_set。不要使用普通的set，测试表明，它的运行速度会长一倍左右，主要是查找的时间复杂度稍劣。同时，BFS需要一个队列，对于每个状态还需要储存当前的移动次数。我选择使用pair型queue存储。也有一种选择，使用map存储状态和移动次数，queue只存储状态，即string类型。测试表明，后者会稍微慢一些，但是区别不大，同时可以存储更多信息。

本题就是对于每个状态，判断上下左右四次移动是否合法并且是否以前做过，如果合法并且没做过，就做一次，新状态加入队列，移动次数加一。如果队列变空，且没有搜索到结束状态，证明无解，输出-1。