853.有边数限制的最短路
==
https://www.acwing.com/problem/content/855/

本题考察限制边长的单源最短路径问题。本题的图中，存在负权边和负权回路。本题考察Bellman-Ford算法。

在有负权回路的情况下，最短路径不一定存在。这是因为，有可能通过无穷次经过负权回路的方式使最短路径长度变为负无穷。但是本题中限制了路径长度，所以这种情况不需要考虑。若不限制长度，Bellman-Ford算法也可以判断最短路径中是否有负权回路。Bellman-Ford算法的时间复杂度为O(mn)，其中m是边的数量，n是点的数量。Bellman-Ford算法不需要将图存储为邻接表或邻接矩阵，直接使用结构体数组就可以。

算法流程如下：算法开始时，置dis[1]=0。循环k次，k为边数限制的数目。每次循环开始时，将dis数组复制到backup数组中。每轮循环中遍历所有边。对于每条边（x,y,z）判断dis[y]>backup[x]+z是否成立。若成立，则将左式的值更新为右式（称为松弛操作）。所有循环结束后，返回dis[n]。若dis[n]大于一定值（本题中可以取0x3f3f3f3f/2），则认为不存在最短路，否则输出返回值作为最短路长度。

本题中需要backup数组的原因是，必须保证在外层的第k层循环中，所有求得的dis值都是经过了数量为k的边。因为遍历所有边的过程中，dis值可能会被更新。而对于后面的边，必须使用上一轮未更新的值来判断，否则不能保证经过边数为n。

对于式子dis[y]>backup[x]+z，在外层的k层循环中，每一次循环，路径长度+1。它会判断在当前路径长度w，从起点出发，若经过边（x,y,z）到达顶点y，能否获得更短的路径长度。有几种情况：

第一：在路径长度为w-1时，起点不能到达顶点x。此时backup[x]的值为无穷大。若z为正值，自然dis[y]不会更新。但若z为负值，更新操作会正常进行，但dis[y]的值仍接近无穷大，视为无穷大。

第二：在路径长度为w-1时，起点能够到达顶点x。此时backup[x]有一个不为无穷大的值，但只是经过w-1条边的最短路径长度，在后面的循环中，这个值可能被更新。此时，若路径长度为w时刚好可以到达顶点y，则dis[y]会将本身与backup[x]+z（即使用长度为w-1的，从结点到顶点x的最短路径，加上当前遍历到的边的长度，所得到的路径之总长度）进行比较，取较小值。若此时dis[y]是无穷大，则一定会被赋值。若dis[y]已经不为无穷大，则会进入”当前路径是否比之前得到的最优路径更优“的判断中。若更优，则更新。这个更新思路与dijkstra算法相近。

该算法可以判断是否因为存在负环而不存在最短路。图中有n个顶点，若不存在影响最短路的负环，则最短路长度最多为n-1。若在外层的第n次循环中，有dis值被更新，则证明到该结点的最短路径长度至少为n，也就是经过了负环。那么，到该结点就不存在最短路径。

对于不存在最短路径的顶点，其dis值不一定是无穷大（本题中取0x3f3f3f3f），可能比其略小。这是因为，如果前面有其他dis值为无穷大的顶点，且两个顶点间的边权值为负，则后面的顶点之dis值会被更新，会比无穷大小一点，但是根据数据范围可以知道，这个更新不会更新太多，可以根据数据范围计算，本题中则是不会减少超过500*10000。若最终的返回值仍大于0x3f3f3f3f/2，则一定是这种情况，不存在最短路。

需要注意，本题与上一题不同，最短路长度可以取到-1。也就是说，不能让算法返回-1表示不存在最短路。可以直接返回dis值，判断是否是无穷大，若是，则没有最短路。若不是，则输出结果。