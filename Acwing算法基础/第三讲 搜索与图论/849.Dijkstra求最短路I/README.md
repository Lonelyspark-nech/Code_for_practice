849.Dijkstra求最短路I
==
https://www.acwing.com/problem/content/description/851/

本题考察朴素Dijkstra算法。该算法适用于单源最短路径问题，图是稠密图，没有负权值的情况可以使用。时间复杂度是O(n^2)。当边数大约是顶点数的平方的时候，可以视为是稠密图。

本题中使用适于存储稠密图的邻接矩阵作为图的存储结构。初始化时，将图中每条边的长度置为无穷大。本题中可能会出现重边和自环，在加边的时候需要和邻接矩阵中的当前边长比较，取较小值。顶点到自身的边长，可能取到无穷，如果加入了自环会是自环的长度，但是在算法执行中没有关系。

Dijkstra算法的初始化，需要一个记录最短路径的长度数组dis[n]，一个记录结点是否完成最短路径查找的状态数组st[N]。算法开始时，dis[1]置为0。然后是外层的一个循环，共循环顶点数n次，每次找出一个顶点，确定其最短路径。找出的方法是，取未找出最短路径的点中dis值最小的顶点。可以证明，该点现在的dis值一定是最短路径的长度。

那之后，更新其他点的dis值。方法是，一层循环，若遍历到的顶点之最短路径长度dis[i]大于当前更新顶点之最短路径长度dis[t]加上t到i的距离G[t][i]，则将前者的值更新为后者。可以发现，当t=i时，该点的dis值一定不会被更新。也就是说，自环不影响该算法的正确性。

当外层循环结束之后输出结果。若dis[n]仍为无穷大，则返回-1，否则返回dis[n]。

需要注意，在选择本轮循环中更新状态的顶点时，若是第一次循环，则一定会选择一号顶点。因为算法初始化时令dis[1]=0，而其余的dis值都是正无穷。

在那之后的循环之中，每次必定选择一个未更新并且距离最短的点，但是需要注意，这个最短距离可能是无穷大。也就是说，每次更新的顶点不一定与起点连通，这种情况下的最短路径长度当然是无穷大。若出现这种情况，可以发现，在那之后的所有点一定不与一号顶点连通，因为一个无穷大的dis值无法更新任何其他顶点的dis值。从而，该算法在某种意义上可以找出和起点相联通的所有顶点，并排除其他顶点。