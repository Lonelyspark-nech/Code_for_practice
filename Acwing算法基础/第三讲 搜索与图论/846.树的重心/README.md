846.树的重心
==
https://www.acwing.com/problem/content/848/

本题考察图的DFS。树可以视为一个无向图。

对任意一个子树进行DFS，DFS会在访问该子树的所有结点之后才返回。根据这个性质，可以用DFS来求子树的大小（不计入根节点），可以将这个大小+1（计入根节点）作为DFS的返回值，表示一个连通块中点的数目。通过对一个结点进行DFS，可以分别求出其所有子树的连通块大小。至于其父节点以及连接的其他结点构成的大连通块，用结点总数减去该结点及其子树的结点数总和可以得到。对于上述连通块的所有值，取最大值，就是“当该结点为重心时的所求取结果”。对整个树进行一次DFS，将这个结果求最小值，就可以得出答案。

有以下几点需要注意：

第一，树可以视为无向图，而邻接表的加边方式是有向的。当读取了边的两个结点时，可以正反进行两次加边操作。这是因为，题目虽然保证给出的是一棵树，但是并不保证编号1是这棵树的根。在极端情况下，若只加单方向的有向边，如果编号1是这棵（倒过来的）树的叶节点，DFS将无法找到任何的相邻节点。正反的两次加边操作，可以保证边的任意一侧都能查找到另外一侧。同时需要注意，题目给出的数据范围限定了结点数量，但是若进行正反两次加边操作的话，存储边的链表需要开二倍大小，也就是e[2*N]和ne[2*n]。h[N]不需要，它的所需长度是结点数。

第二，一定不要忘记对h[N]进行初始化为-1，否则所有元素都是0，在DFS中会陷入死循环。

第三，对于记录搜索状态的数组d[N]，在进入DFS函数时就应修改当前结点的搜索状态。如果修改晚了，可能在搜索下一层结点时倒着搜索回来。

虽然在看视频时完全没法理解示例代码的含义，只记住大致思路，但是按照这个大致思路东拼西凑出来的代码居然和示例代码是一样的。也许这就是记住思路的好处。