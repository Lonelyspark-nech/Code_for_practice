850.Dijkstra求最短路II
==
https://www.acwing.com/problem/content/description/852/

本题考察堆优化的Dijkstra算法。该问题中的图是稀疏图，顶点数n和边数m是一个数量级，都是150000。本题中，图不可以使用邻接矩阵存储，只能使用邻接表存储。

在朴素的dijistra算法中，每轮循环中查找当前dis最小的元素，其时间复杂度是O(n)。若使用堆进行这一操作，其时间复杂度就会变为常数O(1)。但是同时，每轮循环中修改结点的dis值这一操作的时间复杂度也会变化。在原始的算法中，虽然每轮都循环n次，但是很多边长都是无穷大。实际需要判断的边数，就是图的总边数，也就是m。更新操作本身是常数复杂度。

进行堆优化后，有两种情况。第一，手动实现一个堆，保证堆中不多于n个元素。手动实现的堆可以修改堆中的元素，当每次更新时，修改对应顶点的值。当顶点的最短路长度确定时，从堆中弹出对应顶点，直到堆为空为止。修改元素的时间复杂度是O(logn)。最多需要更新m次。这种情况下，算法的总时间复杂度是O(mlogn)。

第二，使用了优先队列。优先队列不能直接修改元素的值，但是可以发现，最短路问题之中，元素只可能越改越小。所以可以将每次修改都插入堆中，较小的新值会在较大的值上方。堆中最多有m个元素。当发现堆顶元素对应的顶点之最短路长度已经确定时，直接continue，选取下一个元素。同样，这种方法也要循环到堆为空为止，所以总时间复杂度是O(mlogm)。但是，m一般小于n^2，否则不能称为稀疏图。也就是mlogm<mlogn^2=2mlogn。即，这两种情况的时间复杂度是一个数量级。所以可以不手动实现一个堆，而是使用优先队列。

算法和朴素Dijkstra算法相似，不需要对重边和自环特殊处理。堆中的元素需要记录当前的dis值以及该值对应的顶点，所以需要使用pair类型。由于需要按照dis值排序，所以pair中两个元素的位置不能互换，一定是dis值在前。堆需要声明为小根堆，声明方法是priority_queue<PII,vector<PII>,greater<PII>>heap;若直接声明而不加额外的参数，默认的类型是大根堆。